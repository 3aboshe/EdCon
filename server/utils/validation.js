/**
 * Validation utilities for user input sanitization
 * 
 * Security-focused validation to prevent:
 * - SQL injection attempts
 * - Homograph attacks (confusable characters)
 * - Username confusion
 * - Invalid character sequences
 */

/**
 * Regular expression for valid access codes (usernames)
 * 
 * Rules:
 * - 3-20 characters long
 * - Only English letters (a-z, A-Z)
 * - Numbers (0-9)
 * - Underscores (_)
 * - Dots (.)
 * - No spaces or special characters
 * - Case-sensitive
 */
const ACCESS_CODE_REGEX = /^[a-zA-Z0-9_.]{3,20}$/;

/**
 * Regular expression for valid user names
 * 
 * Rules:
 * - 1-50 characters long
 * - Unicode letters (supports all languages)
 * - Spaces allowed
 * - Hyphens and apostrophes allowed
 * - No special characters except hyphen, apostrophe, space
 */
const NAME_REGEX = /^[\p{L}\p{M}\s'-]{1,50}$/u;

/**
 * Validate an access code (username)
 * 
 * @param {string} accessCode - The access code to validate
 * @returns {object} { valid: boolean, error: string|null }
 */
function validateAccessCode(accessCode) {
  if (!accessCode || typeof accessCode !== 'string') {
    return {
      valid: false,
      error: 'Access code is required'
    };
  }

  const trimmed = accessCode.trim();

  if (trimmed.length < 3) {
    return {
      valid: false,
      error: 'Access code must be at least 3 characters long'
    };
  }

  if (trimmed.length > 20) {
    return {
      valid: false,
      error: 'Access code must not exceed 20 characters'
    };
  }

  if (!ACCESS_CODE_REGEX.test(trimmed)) {
    return {
      valid: false,
      error: 'Access codes can only contain English letters, numbers, dots (.) and underscores (_). No spaces or special characters allowed.'
    };
  }

  // Check for confusable characters and homograph attacks
  const hasConfusable = /[\u2000-\u200F\u2028-\u202F\u205F-\u206F\uFE00-\uFE0F\uFFF9-\uFFFB]/.test(trimmed);
  if (hasConfusable) {
    return {
      valid: false,
      error: 'Access code contains invalid invisible or special characters'
    };
  }

  // Check for mixed scripts that could be homograph attacks
  // (e.g., mixing Latin and Cyrillic letters that look the same)
  const hasMixedScripts = /[\u0400-\u04FF]/.test(trimmed) && /[a-zA-Z]/.test(trimmed);
  if (hasMixedScripts) {
    return {
      valid: false,
      error: 'Access code cannot mix English letters with characters from other alphabets'
    };
  }

  return { valid: true, error: null };
}

/**
 * Validate a user's display name
 * 
 * @param {string} name - The name to validate
 * @returns {object} { valid: boolean, error: string|null }
 */
function validateName(name) {
  if (!name || typeof name !== 'string') {
    return {
      valid: false,
      error: 'Name is required'
    };
  }

  const trimmed = name.trim();

  if (trimmed.length < 1) {
    return {
      valid: false,
      error: 'Name cannot be empty'
    };
  }

  if (trimmed.length > 50) {
    return {
      valid: false,
      error: 'Name must not exceed 50 characters'
    };
  }

  if (!NAME_REGEX.test(trimmed)) {
    return {
      valid: false,
      error: 'Name contains invalid characters. Only letters, spaces, hyphens, and apostrophes are allowed.'
    };
  }

  return { valid: true, error: null };
}

/**
 * Sanitize an access code by removing dangerous characters
 * 
 * @param {string} accessCode - The access code to sanitize
 * @returns {string} Sanitized access code
 */
function sanitizeAccessCode(accessCode) {
  if (!accessCode) return '';
  
  return accessCode
    .trim()
    .replace(/[\u2000-\u200F\u2028-\u202F\u205F-\u206F\uFE00-\uFE0F\uFFF9-\uFFFB]/g, '') // Remove invisible chars
    .replace(/[^\w.]/g, ''); // Keep only alphanumeric, underscore, and dot
}

/**
 * Validate and sanitize an access code
 * 
 * @param {string} accessCode - The access code to validate and sanitize
 * @returns {object} { valid: boolean, error: string|null, sanitized: string }
 */
function validateAndSanitizeAccessCode(accessCode) {
  const sanitized = sanitizeAccessCode(accessCode);
  const validation = validateAccessCode(sanitized);
  
  return {
    valid: validation.valid,
    error: validation.error,
    sanitized: sanitized
  };
}

/**
 * Check if an access code looks auto-generated
 * (used internally to distinguish custom vs auto codes)
 * 
 * @param {string} accessCode - The access code to check
 * @returns {boolean}
 */
function isAutoGeneratedAccessCode(accessCode) {
  // Auto-generated codes follow patterns like "S123456", "T123456", "P123456"
  return /^[STP]\d+$/.test(accessCode);
}

export {
  validateAccessCode,
  validateName,
  sanitizeAccessCode,
  validateAndSanitizeAccessCode,
  isAutoGeneratedAccessCode,
  ACCESS_CODE_REGEX,
  NAME_REGEX
};
